<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
  <head>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport"    content="width=device-width, initial-scale=1"/>
    <meta name="description" content="Railsガイドは、Ruby on Rails Guidesに基づいた大型リファレンスガイドです。Rails開発の生産性を高めたいときや、Railsの各機能を体系的に学びたいときに役立ちます。" />
    <meta name="keywords"    content="Ruby Rails ガイド 体系的 入門 無料" />
    <meta name="author"      content="Ruby on Rails Community" />

    <meta property="fb:admins"      content="715330868" />
    <meta property="og:title"       content="Ruby on Rails ガイド：体系的に Rails を学ぼう"/>
    <meta property="og:site_name"   content="Ruby on Rails ガイド：体系的に Rails を学ぼう"/>
    <meta property="og:image"       content="http://railsguides.jp/images/cover_for_facebook.png"/>
    <meta property="og:url"         content="http://railsguides.jp/" />
    <meta property="og:type"        content="article" />
    <meta property="og:description" content="Railsガイドは、Ruby on Rails Guidesに基づいた大型リファレンスガイドです。Rails開発の生産性を高めたいときや、Railsの各機能を体系的に学びたいときに役立ちます。" />

    <meta name="twitter:card"  content="summary" />
    <meta name="twitter:site"  content="@RailsGuidesJP" />
    <meta name="twitter:title" content="Ruby on Rails ガイド：体系的に Rails を学ぼう" />
    <meta name="twitter:description" content="Railsガイドは、Ruby on Rails Guidesに基づいた大型リファレンスガイドです。Rails開発の生産性を高めたいときや、Railsの各機能を体系的に学びたいときに役立ちます。" />
    <meta name="twitter:image" content="http://railsguides.jp/images/cover_for_twitter.png" />
    <meta name="twitter:url"   content="http://railsguides.jp/" />

    <title>Active Record クエリインターフェイス | Rails ガイド</title>
    <meta name="apple-mobile-web-app-title" content="Railsガイド" />
    <meta name="application-name"           content="Railsガイド" />

    <link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" />
    <link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" />
    <link rel="stylesheet" type="text/css" href="stylesheets/fixes.css" />

    <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />

    <link rel="apple-touch-icon" sizes="57x57" href="images/favicons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="images/favicons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/favicons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="images/favicons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/favicons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="images/favicons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="images/favicons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="images/favicons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="images/favicons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="images/favicons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="images/favicons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicons/favicon-16x16.png">
    <link rel="manifest" href="manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="images/favicons/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

  </head>
<body class="guide">
  <div id="fb-root"></div>
  <script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=614116885378153&version=v2.0";
    fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">関連サイト: </strong>
      <span class="red-button more-info-button">関連URL</span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="http://guides.rubyonrails.org/">原著 (英語)</a></li>
        <li class="more-info"><a href="https://github.com/yasslab/railsguides.jp">ソースコード (GitHub)</a></li>
        <li class="more-info"><a href="http://railstutorial.jp/">Rails チュートリアル</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="/" title="Return to home page">railsguides.jp</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="/">ホーム</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">ガイド目次</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
              <dl class="L">
                <dt>はじめに</dt>
                <dd><a href="getting_started.html">Rails をはじめよう</a></dd>
                <dt>モデル</dt>
                <dd><a href="active_record_basics.html">Active Record の基礎</a></dd>
                <dd><a href="active_record_migrations.html">Active Record マイグレーション</a></dd>
                <dd><a href="active_record_validations.html">Active Record バリデーション</a></dd>
                <dd><a href="active_record_callbacks.html">Active Record コールバック</a></dd>
                <dd><a href="association_basics.html">Active Record の関連付け</a></dd>
                <dd><a href="active_record_querying.html">Active Record クエリインターフェイス</a></dd>
                <dd><a href="active_model_basics.html">Active Model の基礎</a></dd>
                <dt>ビュー</dt>
                <dd><a href="action_view_overview.html">Action View の概要</a></dd>
                <dd><a href="layouts_and_rendering.html">レイアウトとレンダリング</a></dd>
                <dd><a href="form_helpers.html">Action View フォームヘルパー</a></dd>
                <dt>コントローラ</dt>
                <dd><a href="action_controller_overview.html">Action Controller の概要</a></dd>
                <dd><a href="routing.html">Rails ルーティング</a></dd>
              </dl>
              <dl class="R">
                <dt>高度なトピック</dt>
                <dd><a href="active_support_core_extensions.html">Active Support コア拡張機能</a></dd>
                <dd><a href="i18n.html">Rails 国際化 (i18n) API</a></dd>
                <dd><a href="action_mailer_basics.html">Action Mailer の基礎</a></dd>
                <dd><a href="active_job_basics.html">Active Job の基礎</a></dd>
                <dd><a href="testing.html">Rails テスティングガイド</a></dd>
                <dd><a href="security.html">Rails セキュリティガイド</a></dd>
                <dd><a href="debugging_rails_applications.html">Rails アプリケーションのデバッグ</a></dd>
                <dd><a href="configuring.html">Rails アプリケーションを設定する</a></dd>
                <dd><a href="command_line.html">コマンドラインツールと Rake タスク</a></dd>
                <dd><a href="asset_pipeline.html">アセットパイプライン</a></dd>
                <dd><a href="working_with_javascript_in_rails.html">Rails で JavaScript を使用する</a></dd>
                <dd><a href="initialization.html">Rails の初期化プロセス</a></dd>
                <dd><a href="autoloading_and_reloading_constants.html">定数の自動読み込みと再読み込み</a></dd>
                <dd><a href="caching_with_rails.html">Rails のキャッシュ: 概要</a></dd>
                <dd><a href="active_support_instrumentation.html">Active Support の Instrumentation 機能</a></dd>
                <dd><a href="profiling.html">Rails アプリケーションのプロファイリング</a></dd>
                <dd><a href="api_app.html">Rails による API 専用アプリ</a></dd>
                <dd><a href="action_cable_overview.html">Action Cable の概要</a></dd>
                <dt>Rails を拡張する</dt>
                <dd><a href="plugins.html">Rails プラグイン作成入門</a></dd>
                <dd><a href="rails_on_rack.html">Rails と Rack</a></dd>
                <dd><a href="generators.html">Rails ジェネレータとテンプレート入門</a></dd>
                <dd><a href="engines.html">Rails エンジン入門</a></dd>
                <dt>Ruby on Rails に貢献する</dt>
                <dd><a href="contributing_to_ruby_on_rails.html">Ruby on Rails に貢献する方法</a></dd>
                <dd><a href="development_dependencies_install.html">Rails コア開発環境の構築方法</a></dd>
                <dd><a href="api_documentation_guidelines.html">API ドキュメント作成ガイドライン</a></dd>
                <dd><a href="ruby_on_rails_guides_guidelines.html">Rails ガイドのガイドライン</a></dd>
                <dt>メンテナンスポリシー</dt>
                <dd><a href="maintenance_policy.html">メンテナンスポリシー</a></dd>
                <dt>リリースノート</dt>
                <dd><a href="upgrading_ruby_on_rails.html">Rails アップグレードガイド</a></dd>
                <dd><a href="5_0_release_notes.html">Ruby on Rails 5.0 リリースノート</a></dd>
                <dd><a href="4_2_release_notes.html">Ruby on Rails 4.2 リリースノート</a></dd>
                <dd><a href="4_1_release_notes.html">Ruby on Rails 4.1 リリースノート</a></dd>
                <dd><a href="4_0_release_notes.html">Ruby on Rails 4.0 リリースノート</a></dd>
                <dd><a href="3_2_release_notes.html">Ruby on Rails 3.2 Release Notes [未着手]</a></dd>
                <dd><a href="3_1_release_notes.html">Ruby on Rails 3.1 Release Notes [未着手]</a></dd>
                <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes [未着手]</a></dd>
                <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes [未着手]</a></dd>
                <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes [未着手]</a></dd>
              </dl>
          </div>
        </li>
        <li><a class="nav-item" href="https://github.com/yasslab/railsguides.jp#readme">翻訳に貢献する</a></li>
        <li><a class="nav-item" href="credits.html">原著者</a></li>
        <li><a class="nav-item" href="options.html">電子書籍 (検索対応)</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">ガイド目次</option>
              <optgroup label="はじめに">
                  <option value="getting_started.html">Rails をはじめよう</option>
              </optgroup>
              <optgroup label="モデル">
                  <option value="active_record_basics.html">Active Record の基礎</option>
                  <option value="active_record_migrations.html">Active Record マイグレーション</option>
                  <option value="active_record_validations.html">Active Record バリデーション</option>
                  <option value="active_record_callbacks.html">Active Record コールバック</option>
                  <option value="association_basics.html">Active Record の関連付け</option>
                  <option value="active_record_querying.html">Active Record クエリインターフェイス</option>
                  <option value="active_model_basics.html">Active Model の基礎</option>
              </optgroup>
              <optgroup label="ビュー">
                  <option value="action_view_overview.html">Action View の概要</option>
                  <option value="layouts_and_rendering.html">レイアウトとレンダリング</option>
                  <option value="form_helpers.html">Action View フォームヘルパー</option>
              </optgroup>
              <optgroup label="コントローラ">
                  <option value="action_controller_overview.html">Action Controller の概要</option>
                  <option value="routing.html">Rails ルーティング</option>
              </optgroup>
              <optgroup label="高度なトピック">
                  <option value="active_support_core_extensions.html">Active Support コア拡張機能</option>
                  <option value="i18n.html">Rails 国際化 (i18n) API</option>
                  <option value="action_mailer_basics.html">Action Mailer の基礎</option>
                  <option value="active_job_basics.html">Active Job の基礎</option>
                  <option value="testing.html">Rails テスティングガイド</option>
                  <option value="security.html">Rails セキュリティガイド</option>
                  <option value="debugging_rails_applications.html">Rails アプリケーションのデバッグ</option>
                  <option value="configuring.html">Rails アプリケーションを設定する</option>
                  <option value="command_line.html">コマンドラインツールと Rake タスク</option>
                  <option value="asset_pipeline.html">アセットパイプライン</option>
                  <option value="working_with_javascript_in_rails.html">Rails で JavaScript を使用する</option>
                  <option value="initialization.html">Rails の初期化プロセス</option>
                  <option value="autoloading_and_reloading_constants.html">定数の自動読み込みと再読み込み</option>
                  <option value="caching_with_rails.html">Rails のキャッシュ: 概要</option>
                  <option value="active_support_instrumentation.html">Active Support の Instrumentation 機能</option>
                  <option value="profiling.html">Rails アプリケーションのプロファイリング</option>
                  <option value="api_app.html">Rails による API 専用アプリ</option>
                  <option value="action_cable_overview.html">Action Cable の概要</option>
              </optgroup>
              <optgroup label="Rails を拡張する">
                  <option value="plugins.html">Rails プラグイン作成入門</option>
                  <option value="rails_on_rack.html">Rails と Rack</option>
                  <option value="generators.html">Rails ジェネレータとテンプレート入門</option>
                  <option value="engines.html">Rails エンジン入門</option>
              </optgroup>
              <optgroup label="Ruby on Rails に貢献する">
                  <option value="contributing_to_ruby_on_rails.html">Ruby on Rails に貢献する方法</option>
                  <option value="development_dependencies_install.html">Rails コア開発環境の構築方法</option>
                  <option value="api_documentation_guidelines.html">API ドキュメント作成ガイドライン</option>
                  <option value="ruby_on_rails_guides_guidelines.html">Rails ガイドのガイドライン</option>
              </optgroup>
              <optgroup label="メンテナンスポリシー">
                  <option value="maintenance_policy.html">メンテナンスポリシー</option>
              </optgroup>
              <optgroup label="リリースノート">
                  <option value="upgrading_ruby_on_rails.html">Rails アップグレードガイド</option>
                  <option value="5_0_release_notes.html">Ruby on Rails 5.0 リリースノート</option>
                  <option value="4_2_release_notes.html">Ruby on Rails 4.2 リリースノート</option>
                  <option value="4_1_release_notes.html">Ruby on Rails 4.1 リリースノート</option>
                  <option value="4_0_release_notes.html">Ruby on Rails 4.0 リリースノート</option>
                  <option value="3_2_release_notes.html">Ruby on Rails 3.2 Release Notes [未着手]</option>
                  <option value="3_1_release_notes.html">Ruby on Rails 3.1 Release Notes [未着手]</option>
                  <option value="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes [未着手]</option>
                  <option value="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes [未着手]</option>
                  <option value="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes [未着手]</option>
              </optgroup>
          </select>
        </li>
      </ul>
      </div>
    </div>
  </div>
  <hr class="hide" />
  <div id="feature">
  <div class="wrapper">
      <h2>Active Record クエリインターフェイス</h2><p>このガイドでは、Active Recordを使用してデータベースからデータを取り出すためのさまざまな方法について解説します。</p><p>このガイドの内容:</p>
<ul>
<li>多くのメソッドや条件を駆使してレコードを検索する</li>
<li>検索されたレコードのソート順、取り出したい属性、グループ化の有無などを指定する</li>
<li>一括読み込み (eager loading) を使用して、データ取り出しに必要なクエリの実行回数を減らす</li>
<li>動的検索メソッドを使用する</li>
<li>複数のActive Record メソッドを連鎖 (chain) させて同時に利用する</li>
<li>特定のレコードが存在するかどうかをチェックする</li>
<li>Active Recordモデルでさまざまな計算を行う</li>
<li>リレーションでEXPLAINを実行する</li>
</ul>

                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />目次</h3>
            <ol class="chapters">
<li>
<a href="#%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99">データベースからオブジェクトを取り出す</a>

<ul>
<li><a href="#%E5%8D%98%E4%B8%80%E3%81%AE%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99">単一のオブジェクトを取り出す</a></li>
<li><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E3%83%90%E3%83%83%E3%83%81%E3%81%A7%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99">複数のオブジェクトをバッチで取り出す</a></li>
</ul>
</li>
<li>
<a href="#%E6%9D%A1%E4%BB%B6">条件</a>

<ul>
<li><a href="#%E6%96%87%E5%AD%97%E5%88%97%E3%81%A0%E3%81%91%E3%81%A7%E8%A1%A8%E3%81%95%E3%82%8C%E3%81%9F%E6%9D%A1%E4%BB%B6">文字列だけで表された条件</a></li>
<li><a href="#%E9%85%8D%E5%88%97%E3%81%A7%E8%A1%A8%E3%81%95%E3%82%8C%E3%81%9F%E6%9D%A1%E4%BB%B6">配列で表された条件</a></li>
<li><a href="#%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%9F%E6%9D%A1%E4%BB%B6">ハッシュを使用した条件</a></li>
<li><a href="#not%E6%9D%A1%E4%BB%B6">NOT条件</a></li>
</ul>
</li>
<li><a href="#%E4%B8%A6%E3%81%B3%E9%A0%86">並び順</a></li>
<li><a href="#%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89%E3%81%A0%E3%81%91%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99">特定のフィールドだけを取り出す</a></li>
<li><a href="#limit%E3%81%A8offset">LimitとOffset</a></li>
<li>
<a href="#%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97">グループ</a>

<ul>
<li><a href="#%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97%E5%8C%96%E3%81%95%E3%82%8C%E3%81%9F%E9%A0%85%E7%9B%AE%E3%81%AE%E5%90%88%E8%A8%88">グループ化された項目の合計</a></li>
</ul>
</li>
<li><a href="#having">Having</a></li>
<li>
<a href="#%E6%9D%A1%E4%BB%B6%E3%82%92%E4%B8%8A%E6%9B%B8%E3%81%8D%E3%81%99%E3%82%8B">条件を上書きする</a>

<ul>
<li><a href="#unscope"><code>unscope</code></a></li>
<li><a href="#only"><code>only</code></a></li>
<li><a href="#reorder"><code>reorder</code></a></li>
<li><a href="#reverse-order"><code>reverse_order</code></a></li>
<li><a href="#rewhere"><code>rewhere</code></a></li>
</ul>
</li>
<li><a href="#null%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">Nullリレーション</a></li>
<li><a href="#%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8A%E5%B0%82%E7%94%A8%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88">読み取り専用オブジェクト</a></li>
<li>
<a href="#%E3%83%AC%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B4%E6%96%B0%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E3%82%88%E3%81%86%E3%83%AD%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B">レコードを更新できないようロックする</a>

<ul>
<li><a href="#%E6%A5%BD%E8%A6%B3%E7%9A%84%E3%83%AD%E3%83%83%E3%82%AF-optimistic">楽観的ロック (optimistic)</a></li>
<li><a href="#%E6%82%B2%E8%A6%B3%E7%9A%84%E3%83%AD%E3%83%83%E3%82%AF-pessimistic">悲観的ロック (pessimistic)</a></li>
</ul>
</li>
<li>
<a href="#%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%82%92%E7%B5%90%E5%90%88%E3%81%99%E3%82%8B">テーブルを結合する</a>

<ul>
<li><a href="#sql%E3%83%95%E3%83%A9%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E6%96%87%E5%AD%97%E5%88%97%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B">SQLフラグメント文字列を使用する</a></li>
<li><a href="#%E5%90%8D%E5%89%8D%E4%BB%98%E3%81%8D%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E9%85%8D%E5%88%97-%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B">名前付き関連付けの配列/ハッシュを使用する</a></li>
<li><a href="#%E7%B5%90%E5%90%88%E3%81%95%E3%82%8C%E3%81%9F%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%81%A7%E6%9D%A1%E4%BB%B6%E3%82%92%E6%8C%87%E5%AE%9A%E3%81%99%E3%82%8B">結合されたテーブルで条件を指定する</a></li>
</ul>
</li>
<li>
<a href="#%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%92%E4%B8%80%E6%8B%AC%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF%E3%81%99%E3%82%8B">関連付けを一括読み込みする</a>

<ul>
<li><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%92%E4%B8%80%E6%8B%AC%E3%81%A7%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%80">複数の関連付けを一括で読み込む</a></li>
<li><a href="#%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E4%B8%80%E6%8B%AC%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF%E3%81%A7%E6%9D%A1%E4%BB%B6%E3%82%92%E6%8C%87%E5%AE%9A%E3%81%99%E3%82%8B">関連付けの一括読み込みで条件を指定する</a></li>
</ul>
</li>
<li>
<a href="#%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97">スコープ</a>

<ul>
<li><a href="#%E5%BC%95%E6%95%B0%E3%82%92%E6%B8%A1%E3%81%99">引数を渡す</a></li>
<li><a href="#%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%82%92%E9%81%A9%E7%94%A8%E3%81%99%E3%82%8B">デフォルトスコープを適用する</a></li>
<li><a href="#%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%AE%E3%83%9E%E3%83%BC%E3%82%B8">スコープのマージ</a></li>
<li><a href="#%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%82%92%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B">すべてのスコープを削除する</a></li>
</ul>
</li>
<li><a href="#%E5%8B%95%E7%9A%84%E3%83%95%E3%82%A1%E3%82%A4%E3%83%B3%E3%83%80">動的ファインダ</a></li>
<li>
<a href="#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%83%81%E3%82%A7%E3%82%A4%E3%83%B3%E3%82%92%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B">メソッドチェインを理解する</a>

<ul>
<li><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%81%8B%E3%82%89%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF%E3%81%97%E3%81%A6%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B">複数のテーブルからのデータをフィルタして取得する</a></li>
<li><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%81%8B%E3%82%89%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B">複数のテーブルから特定のデータを取得する</a></li>
</ul>
</li>
<li>
<a href="#%E6%96%B0%E3%81%97%E3%81%84%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E6%A4%9C%E7%B4%A2%E3%81%BE%E3%81%9F%E3%81%AF%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B">新しいオブジェクトを検索またはビルドする</a>

<ul>
<li><a href="#find-or-create-by"><code>find_or_create_by</code></a></li>
<li><a href="#find-or-create-by-bang"><code>find_or_create_by!</code></a></li>
<li><a href="#find-or-initialize-by"><code>find_or_initialize_by</code></a></li>
</ul>
</li>
<li>
<a href="#sql%E3%81%A7%E6%A4%9C%E7%B4%A2%E3%81%99%E3%82%8B">SQLで検索する</a>

<ul>
<li><a href="#select-all"><code>select_all</code></a></li>
<li><a href="#pluck"><code>pluck</code></a></li>
<li><a href="#ids"><code>ids</code></a></li>
</ul>
</li>
<li><a href="#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%AD%98%E5%9C%A8%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF">オブジェクトの存在チェック</a></li>
<li>
<a href="#%E8%A8%88%E7%AE%97">計算</a>

<ul>
<li><a href="#%E5%80%8B%E6%95%B0%E3%82%92%E6%95%B0%E3%81%88%E3%82%8B">個数を数える</a></li>
<li><a href="#%E5%B9%B3%E5%9D%87">平均</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E5%80%A4">最小値</a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E5%80%A4">最大値</a></li>
<li><a href="#%E5%90%88%E8%A8%88">合計</a></li>
</ul>
</li>
<li>
<a href="#explain%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B">EXPLAINを実行する</a>

<ul>
<li><a href="#explain%E3%81%AE%E5%87%BA%E5%8A%9B%E7%B5%90%E6%9E%9C%E3%82%92%E8%A7%A3%E9%87%88%E3%81%99%E3%82%8B">EXPLAINの出力結果を解釈する</a></li>
</ul>
</li>
</ol>

          </div>
</div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <p>生のSQLを使用してデータベースのレコードを検索することに慣れきった人がRailsに出会うと、Railsでは同じ操作をずっと洗練された方法で実現できることに気付くでしょう。Active Recordを使用することで、SQLを直に実行する必要はほぼなくなります。</p><p>本ガイドのコード例では、基本的に以下のモデルを使用します。</p><div class="info"><p>特に記さない限り、モデル中の<code>id</code>は主キーを表します。</p></div><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Address &lt; ActiveRecord::Base
  belongs_to :client
end

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :client, counter_cache: true
end

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Role &lt; ActiveRecord::Base
  has_and_belongs_to_many :clients
end

</pre>
</div>
<p>Active Recordは、ユーザーに代わってデータベースにクエリを発行します。発行されるクエリは多くのデータベースシステム (MySQL、PostgreSQL、SQLiteなど) と互換性があります。Active Recordを使用していれば、利用しているデータベースシステムの種類にかかわらず、同じ表記を使用できます。</p><h3 id="データベースからオブジェクトを取り出す"><a href="#%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%8B%E3%82%89%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99">1 データベースからオブジェクトを取り出す</a></h3><p>Active Recordでは、データベースからオブジェクトを取り出すための検索メソッドを多数用意しています。これらの検索メソッドを使用することで、生のSQLを書くことなく、データベースへの特定のクエリを実行するための引数を渡すことができます。</p><p>以下のメソッドが用意されています。</p>
<ul>
<li><code>bind</code></li>
<li><code>create_with</code></li>
<li><code>distinct</code></li>
<li><code>eager_load</code></li>
<li><code>extending</code></li>
<li><code>from</code></li>
<li><code>group</code></li>
<li><code>having</code></li>
<li><code>includes</code></li>
<li><code>joins</code></li>
<li><code>limit</code></li>
<li><code>lock</code></li>
<li><code>none</code></li>
<li><code>offset</code></li>
<li><code>order</code></li>
<li><code>preload</code></li>
<li><code>readonly</code></li>
<li><code>references</code></li>
<li><code>reorder</code></li>
<li><code>reverse_order</code></li>
<li><code>select</code></li>
<li><code>uniq</code></li>
<li><code>where</code></li>
</ul>
<p>上のメソッドは、すべて<code>ActiveRecord::Relation</code>のインスタンスを返します。</p><p><code>Model.find(options)</code>という操作を要約すると以下のようになります。</p>
<ul>
<li>与えられたオプションを同等のSQLクエリに変換します。</li>
<li>SQLクエリを発行し、該当する結果をデータベースから取り出します。</li>
<li>得られた結果を行ごとに同等のRubyオブジェクトとしてインスタンス化します。</li>
<li>指定されていれば、<code>after_find</code>を実行し、続いて<code>after_initialize</code>コールバックを実行します。</li>
</ul>
<h4 id="単一のオブジェクトを取り出す"><a href="#%E5%8D%98%E4%B8%80%E3%81%AE%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99">1.1 単一のオブジェクトを取り出す</a></h4><p>Active Recordには、単一のオブジェクトを取り出すためのさまざま方法が用意されています。</p><h5 id="find"><a href="#find">1.1.1 <code>find</code></a></h5><p><code>find</code>メソッドを使用すると、与えられたどのオプションにもマッチする <em>主キー</em> に対応するオブジェクトを取り出すことができます。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Find the client with primary key (id) 10.
client = Client.find(10)
# =&gt; #&lt;Client id: 10, first_name: "Ryan"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1

</pre>
</div>
<p><code>find</code>メソッドでマッチするレコードが見つからない場合、<code>ActiveRecord::RecordNotFound</code>例外が発生します。</p><p>このメソッドを使用して、複数のオブジェクトへのクエリを作成することもできます。これを行うには、<code>find</code>メソッドの呼び出し時に主キーの配列を渡します。これにより、与えられた <em>主キー</em> にマッチするレコードをすべて含む配列が返されます。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Find the clients with primary keys 1 and 10.
client = Client.find([1, 10]) # Client.find(1, 10)でもよい
# =&gt; [#&lt;Client id: 1, first_name: "Lifo"&gt;, #&lt;Client id: 10, first_name: "Ryan"&gt;]

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.id IN (1,10))

</pre>
</div>
<div class="warning"><p><code>find</code>メソッドで与えられた主キーの中に、どのレコードにもマッチしない主キーが<strong>1つでも</strong>あると、<code>ActiveRecord::RecordNotFound</code>例外が発生します。</p></div><h5 id="take"><a href="#take">1.1.2 <code>take</code></a></h5><p><code>take</code>メソッドはレコードを1つ取り出します。どのレコードが取り出されるかは指定されません。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.take
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 1

</pre>
</div>
<p><code>Model.take</code>は、モデルにレコードが1つもない場合に<code>nil</code>を返します。このとき例外は発生しません。</p><p><code>take</code>メソッドで返すレコードの最大数を数値の引数で指定することもできます。例:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.take(2)
# =&gt; [
  #&lt;Client id: 1, first_name: "Lifo"&gt;,
  #&lt;Client id: 220, first_name: "Sara"&gt;
]

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 2

</pre>
</div>
<p><code>take!</code>メソッドの動作は、<code>take</code>メソッドとまったく同じです。ただし、<code>take!</code>メソッドでは、マッチするレコードが見つからない場合に<code>ActiveRecord::RecordNotFound</code>例外が発生する点だけが異なります。</p><div class="info"><p>このメソッドで取り出されるレコードは、使用するデータベースエンジンによっても異なることがあります。</p></div><h5 id="first"><a href="#first">1.1.3 <code>first</code></a></h5><p><code>first</code>メソッドは、主キー順の最初のレコードを取り出します。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.first
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1

</pre>
</div>
<p><code>first</code>メソッドは、モデルにレコードが1つもない場合に<code>nil</code>を返します。このとき例外は発生しません。</p><p><code>first</code>メソッドで返すレコードの最大数を数値の引数で指定することもできます。例：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.first(3)
# =&gt; [
  #&lt;Client id: 1, first_name: "Lifo"&gt;,
  #&lt;Client id: 2, first_name: "Fifo"&gt;,
  #&lt;Client id: 3, first_name: "Filo"&gt;
]

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3

</pre>
</div>
<p><code>first!</code>メソッドの動作は、マッチするレコードが見つからない場合に<code>ActiveRecord::RecordNotFound</code>例外が発生する点を除いて、<code>first</code>メソッドとまったく同じです。</p><h5 id="last"><a href="#last">1.1.4 <code>last</code></a></h5><p><code>last</code>メソッドは、主キー順の最後のレコードを取り出します。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.last
# =&gt; #&lt;Client id: 221, first_name: "Russel"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1

</pre>
</div>
<p>last<code>メソッドは、モデルにレコードが1つもない場合に</code>nil`を返します。このとき例外は発生しません。</p><p><code>last</code>メソッドで返すレコードの最大数を数値の引数で指定することもできます。例:</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.last(3)
# =&gt; [
  #&lt;Client id: 219, first_name: "James"&gt;,
  #&lt;Client id: 220, first_name: "Sara"&gt;,
  #&lt;Client id: 221, first_name: "Russel"&gt;
]

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3

</pre>
</div>
<p><code>last!</code>メソッドの動作は、マッチするレコードが見つからない場合に<code>ActiveRecord::RecordNotFound</code>例外が発生する点を除いて、<code>last</code>メソッドとまったく同じです。</p><h5 id="find-by"><a href="#find-by">1.1.5 <code>find_by</code></a></h5><p><code>find_by</code>メソッドは、与えられた条件にマッチするレコードのうち最初のレコードだけを返します。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_by first_name: 'Lifo'
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

Client.find_by first_name: 'Jon'
# =&gt; nil

</pre>
</div>
<p>上の文は以下のように書くこともできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(first_name: 'Lifo').take

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.first_name = 'Lifo') LIMIT 1

</pre>
</div>
<p><code>find_by!</code>メソッドの動作は、マッチするレコードが見つからない場合に<code>ActiveRecord::RecordNotFound</code>例外が発生する点を除いて、<code>find_by</code>メソッドとまったく同じです。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_by! first_name: 'does not exist'
# =&gt; ActiveRecord::RecordNotFound

</pre>
</div>
<p>上の文は以下のように書くこともできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(first_name: 'does not exist').take!

</pre>
</div>
<h4 id="複数のオブジェクトをバッチで取り出す"><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E3%83%90%E3%83%83%E3%83%81%E3%81%A7%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99">1.2 複数のオブジェクトをバッチで取り出す</a></h4><p>多数のレコードに対して反復処理を行いたいことがあります。たとえば、多くのユーザーにニュースレターを送信したい、データをエクスポートしたいなどです。</p><p>このような処理をそのまま実装すると以下のようになるでしょう。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# このような処理を数千件ものレコードに対して実行すると、効率が大幅に低下します。
User.all.each do |user|
  NewsMailer.weekly(user).deliver_now
end

</pre>
</div>
<p>しかし上のような処理は、テーブルのサイズが大きくなるにつれて非現実的になります。<code>User.all.each</code>は、Active Recordに対して <em>テーブル全体</em> を一度に取り出し、しかも1行ごとにオブジェクトを生成し、その巨大なモデルオブジェクトの配列をメモリに配置するからです。もし莫大な数のレコードに対してこのようなコードをまともに実行すると、コレクション全体のサイズがメモリ容量を上回ってしまうことでしょう。</p><p>Railsでは、メモリを圧迫しないサイズにバッチを分割して処理するための方法を2とおり提供しています。1つ目は<code>find_each</code>メソッドを使用する方法です。これは、レコードのバッチを1つ取り出し、次に <em>各</em> レコードを1つのモデルとして個別にブロックにyieldします。2つ目の方法は<code>find_in_batches</code>メソッドを使用する方法です。レコードのバッチを1つ取り出し、次に <em>バッチ全体</em> をモデルの配列としてブロックにyieldします。</p><div class="info"><p><code>find_each</code>メソッドと<code>find_in_batches</code>メソッドは、一度にメモリに読み込めないような大量のレコードに対するバッチ処理のためのものです。数千のレコードに対して単にループ処理を行なうのであれば通常の検索メソッドで十分です。</p></div><h5 id="find-each"><a href="#find-each">1.2.1 <code>find_each</code></a></h5><p><code>find_each</code>メソッドは、レコードのバッチを1つ取り出し、続いて <em>各</em> レコードを1つのモデルとして個別にブロックにyieldします。以下の例では、<code>find_each</code>で1000件のレコードを取り出しています。この件数は<code>find_each</code>と<code>find_in_batches</code>のどちらでもデフォルト値として使用されており、続いて各レコードを1つのモデルとしてブロックに個別にyieldします。この処理は、すべてのレコードが処理されるまで繰り返されます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.find_each do |user|
  NewsMailer.weekly(user).deliver_now
end

</pre>
</div>
<p><code>find_each</code>では、<code>where</code>などのActive Recordメソッドを連鎖 (chain) させることで条件を追加することができます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.where(weekly_subscriber: true).find_each do |user|
  NewsMailer.weekly(user).deliver_now
end

</pre>
</div>
<h6 id="find-eachのオプション"><a href="#find-each%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3">1.2.1.1 <code>find_each</code>のオプション</a></h6><p><code>find_each</code>メソッドでは、通常の<code>find</code>メソッドとほぼ同じオプションが使用できます。<code>:order</code>と<code>:limit</code>は<code>find_each</code>内部で利用するために予約されており、使用できません。</p><p>このメソッドでは、通常のオプションの他に<code>:batch_size</code>、<code>:begin_at</code>、<code>:end_at</code>も利用できます。</p><p><strong><code>:batch_size</code></strong></p><p><code>:batch_size</code>オプションは、(ブロックに個別に渡される前に) 1回のバッチで取り出すレコード数を指定します。たとえば、1回に5000件ずつ処理したい場合は以下のように指定します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.find_each(batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end

</pre>
</div>
<p><strong><code>:begin_at</code></strong></p><p>デフォルトでは、レコードは主キーの昇順に取り出されます。主キーは整数でなければなりません。あるIDより小さいIDを除外したい場合は、<code>:begin_at</code>オプションを使用していつでもシーケンスの開始IDを指定できます。これは、たとえば中断したバッチ処理を再開する場合などに便利です (最後に実行された処理のIDがチェックポイントとして保存済みであることが前提です)。</p><p>たとえば、1回のバッチで5000件を取り出し、主キーが2000以降のユーザーだけにニュースレターを送信したい場合は以下のようにします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.find_each(begin_at: 2000, batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end

</pre>
</div>
<p>他にも、同じ処理キューを複数の作業者で手分けする場合が考えられます。たとえば、<code>:begin_at</code>オプションを適切に使用して、作業者1人につき10000レコードずつ割り当てることができます。</p><p><strong><code>:end_at</code></strong></p><p><code>:begin_at</code>オプションと同様、あるIDより大きいIDを除外したい場合は、<code>:end_at</code>オプションを使用していつでもシーケンスの終了IDを指定できます。
これは、たとえば中断したバッチ処理を再開する場合などに便利です。<code>:begin_at</code>と<code>:end_at</code>でレコードのサブセットを指定します。</p><p>たとえば、1回のバッチで5000件を取り出し、主キーが2000から10000のユーザーだけにニュースレターを送信したい場合は以下のようにします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.find_each(begin_at: 2000, end_at: 10000, batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end

</pre>
</div>
<h5 id="find-in-batches"><a href="#find-in-batches">1.2.2 <code>find_in_batches</code></a></h5><p><code>find_in_batches</code>メソッドは、レコードをバッチで取り出すという点で<code>find_each</code>と似ています。違うのは、<code>find_in_batches</code>は <em>バッチ</em> を個別にではなくモデルの配列としてブロックにyieldするという点です。以下の例では、与えられたブロックに対して一度に最大1000までの納品書 (invoice) の配列をyieldしています。最後のブロックには残りの納品書が含まれます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# 1回あたりadd_invoicesに納品書1000通の配列を渡す
Invoice.find_in_batches do |invoices|
  export.add_invoices(invoices)
end

</pre>
</div>
<h6 id="find-in-batchesのオプション"><a href="#find-in-batches%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3">1.2.2.1 <code>find_in_batches</code>のオプション</a></h6><p><code>find_in_batches</code>メソッドでは、<code>find_each</code>メソッドと同様に<code>:batch_size</code>、<code>:begin_at</code>、<code>:end_at</code>オプションを使用できます。</p><h3 id="条件"><a href="#%E6%9D%A1%E4%BB%B6">2 条件</a></h3><p><code>where</code>メソッドは、返されるレコードを制限するための条件を指定します。SQL文で言う<code>WHERE</code>の部分に相当します。条件は、文字列、配列、ハッシュのいずれかの方法で与えることができます。</p><h4 id="文字列だけで表された条件"><a href="#%E6%96%87%E5%AD%97%E5%88%97%E3%81%A0%E3%81%91%E3%81%A7%E8%A1%A8%E3%81%95%E3%82%8C%E3%81%9F%E6%9D%A1%E4%BB%B6">2.1 文字列だけで表された条件</a></h4><p>検索メソッドに条件を追加したい場合、たとえば<code>Client.where("orders_count = '2'")</code>のように条件を単純に指定することができます。この場合、<code>orders_count</code>フィールドの値が2であるすべてのクライアントが検索されます。</p><div class="warning"><p>条件を文字列だけで構成すると、SQLインジェクションの脆弱性が発生する可能性があります。たとえば、<code>Client.where("first_name LIKE '%#{params[:first_name]}%'")</code>という書き方は危険です。次で説明するように、配列を使用するのが望ましい方法です。</p></div><h4 id="配列で表された条件"><a href="#%E9%85%8D%E5%88%97%E3%81%A7%E8%A1%A8%E3%81%95%E3%82%8C%E3%81%9F%E6%9D%A1%E4%BB%B6">2.2 配列で表された条件</a></h4><p>条件で使用する数値が変動する可能性がある場合、引数をどのようにすればよいでしょうか。この場合は以下のようにします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count = ?", params[:orders])

</pre>
</div>
<p>Active Recordは条件値の最初の要素を調べ、その後に要素が追加されていたら、最初の要素の中にある疑問符<code>(?)</code>を追加要素で置き換えます。</p><p>複数の条件を指定したい場合は次のようにします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count = ?AND locked = ?", params[:orders], false)

</pre>
</div>
<p>上の例では、1つ目の疑問符は<code>params[:orders]</code>の値で置き換えられ、2つ目の疑問符は<code>false</code>をSQL形式に変換したもの (変換方法はアダプタによって異なる) で置き換えられます。</p><p>以下のようなコードの書き方を強く推奨します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count = ?", params[:orders])

</pre>
</div>
<p>以下の書き方は危険であり、避ける必要があります。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count = #{params[:orders]}")

</pre>
</div>
<p>条件文字列の中に変数を直接置くと、その変数はデータベースに <strong>そのまま</strong> 渡されてしまいます。これは、悪意のある人物がエスケープされていない危険な変数を渡すことができるということです。このようなコードがあると、悪意のある人物がデータベースを意のままにすることができ、データベース全体が危険にさらされます。くれぐれも、条件文字列の中に引数を直接置くことはしないでください。</p><div class="info"><p>SQLインジェクションの詳細については<a href="security.html#sql%E3%82%A4%E3%83%B3%E3%82%B8%E3%82%A7%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3">Ruby on Railsセキュリティガイド</a>を参照してください。</p></div><h5 id="プレースホルダを使用した条件"><a href="#%E3%83%97%E3%83%AC%E3%83%BC%E3%82%B9%E3%83%9B%E3%83%AB%E3%83%80%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%9F%E6%9D%A1%E4%BB%B6">2.2.1 プレースホルダを使用した条件</a></h5><p>疑問符<code>(?)</code>をパラメータで置き換えるスタイルと同様、配列による条件中でキー/値のハッシュを指定できます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("created_at &gt;= :start_date AND created_at &lt;= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})

</pre>
</div>
<p>このように書くことで、条件で多数の変数が使用されている場合にコードが読みやすくなります。</p><h4 id="ハッシュを使用した条件"><a href="#%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%9F%E6%9D%A1%E4%BB%B6">2.3 ハッシュを使用した条件</a></h4><p>Active Recordは条件をハッシュで渡すこともできます。この書式を使用することで条件構文が読みやすくなります。条件をハッシュで渡す場合、ハッシュのキーには条件付けしたいフィールドを、ハッシュの値にはそのフィールドをどのように条件づけするかを、それぞれ指定します。</p><div class="note"><p>ハッシュによる条件は、等値、範囲、サブセットのチェックでのみ使用できます。</p></div><h5 id="等値条件"><a href="#%E7%AD%89%E5%80%A4%E6%9D%A1%E4%BB%B6">2.3.1 等値条件</a></h5><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(locked: true)

</pre>
</div>
<p>フィールド名は文字列形式にすることもできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where('locked' =&gt; true)

</pre>
</div>
<p>belongs_toリレーションシップの場合、Active Recordオブジェクトが値として使用されていれば、モデルを指定する時に関連付けキーを使用できます。この方法はポリモーフィックリレーションシップでも同様に使用できます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.where(author: author)
Author.joins(:articles).where(articles: { author: author })

</pre>
</div>
<div class="note"><p>この値はシンボルにすることはできません。たとえば<code>Client.where(status: :active)</code>のような書き方はできません。</p></div><h5 id="範囲条件"><a href="#%E7%AF%84%E5%9B%B2%E6%9D%A1%E4%BB%B6">2.3.2 範囲条件</a></h5><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)

</pre>
</div>
<p>上の例では、昨日作成されたすべてのクライアントを検索します。内部ではSQLの<code>BETWEEN</code>文が使用されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')

</pre>
</div>
<p><a href="#%E9%85%8D%E5%88%97%E3%81%A7%E8%A1%A8%E3%81%95%E3%82%8C%E3%81%9F%E6%9D%A1%E4%BB%B6">配列で表された条件</a>では、さらに簡潔な文例をご紹介しています。</p><h5 id="サブセット条件"><a href="#%E3%82%B5%E3%83%96%E3%82%BB%E3%83%83%E3%83%88%E6%9D%A1%E4%BB%B6">2.3.3 サブセット条件</a></h5><p>SQLの<code>IN</code>式を使用してレコードを検索したい場合、条件ハッシュにそのための配列を1つ渡すことができます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(orders_count: [1,3,5])

</pre>
</div>
<p>上のコードを実行すると、以下のようなSQLが生成されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))

</pre>
</div>
<h4 id="not条件"><a href="#not%E6%9D%A1%E4%BB%B6">2.4 NOT条件</a></h4><p>SQLの<code>NOT</code>クエリは、<code>where.not</code>で表せます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.where.not(author: author)

</pre>
</div>
<p>言い換えれば、このクエリは<code>where</code>に引数を付けずに呼び出し、直後に<code>where</code>条件に<code>not</code>を渡して連鎖させることによって生成されています。</p><h3 id="並び順"><a href="#%E4%B8%A6%E3%81%B3%E9%A0%86">3 並び順</a></h3><p>データベースから取り出すレコードを特定の順序で並べ替えたい場合、<code>order</code>を使用できます。</p><p>たとえば、ひとかたまりのレコードを取り出し、それをテーブル内の<code>created_at</code>の昇順で並べたい場合には以下のようにします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.order(:created_at)
# または
Client.order("created_at")

</pre>
</div>
<p><code>ASC</code>(昇順)や<code>DESC</code>(降順)を指定することもできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.order(created_at: :desc)
# または
Client.order(created_at: :asc)
# または
Client.order("created_at DESC")
# または
Client.order("created_at ASC")

</pre>
</div>
<p>複数のフィールドを指定して並べることもできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.order(orders_count: :asc, created_at: :desc)
# または
Client.order(:orders_count, created_at: :desc)
# または
Client.order("orders_count ASC, created_at DESC")
# または
Client.order("orders_count ASC", "created_at DESC")

</pre>
</div>
<p><code>order</code>メソッドを (条件を変えて) 複数回呼び出すと、最初の並び順に新しい並び順が追加されます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC

</pre>
</div>
<h3 id="特定のフィールドだけを取り出す"><a href="#%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89%E3%81%A0%E3%81%91%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99">4 特定のフィールドだけを取り出す</a></h3><p>デフォルトでは、<code>Model.find</code>を実行すると、結果セットからすべてのフィールドが選択されます。内部的にはSQLの<code>select *</code>が実行されています。</p><p>結果セットから特定のフィールドだけを取り出したい場合、<code>select</code>メソッドを使用できます。</p><p>たとえば、<code>viewable_by</code>カラムと<code>locked</code>カラムだけを取り出したい場合は以下のようにします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.select("viewable_by, locked")

</pre>
</div>
<p>上で実際に使用されるSQL文は以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT viewable_by, locked FROM clients

</pre>
</div>
<p>selectを使用すると、選択したフィールドだけを使用してモデルオブジェクトが初期化されるため、注意してください。モデルオブジェクトの初期化時に指定しなかったフィールドにアクセスしようとすると、以下のメッセージが表示されます。</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
ActiveModel::MissingAttributeError: missing attribute: &lt;属性名&gt;

</pre>
</div>
<p><code>&lt;属性名&gt;</code>は、アクセスしようとした属性です。<code>id</code>メソッドは、この<code>ActiveRecord::MissingAttributeError</code>を発生しません。このため、関連付けを扱う場合には注意してください。関連付けが正常に動作するには<code>id</code>メソッドが必要だからです。</p><p>特定のフィールドについて、重複のない一意の値を1レコードだけ取り出したい場合、<code>distinct</code>を使用できます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.select(:name).distinct

</pre>
</div>
<p>上のコードを実行すると、以下のようなSQLが生成されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT DISTINCT name FROM clients

</pre>
</div>
<p>一意性の制約を外すこともできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
query = Client.select(:name).distinct
# =&gt; 重複のない一意の名前が返される

query.distinct(false)
# =&gt; 重複の有無を問わずすべての名前が返される

</pre>
</div>
<h3 id="limitとoffset"><a href="#limit%E3%81%A8offset">5 LimitとOffset</a></h3><p><code>Model.find</code>で実行されるSQLに<code>LIMIT</code>を適用したい場合、リレーションで<code>limit</code>メソッドと<code>offset</code>メソッドを使用することで<code>LIMIT</code>を指定できます。</p><p><code>limit</code>メソッドは、取り出すレコード数の上限を指定します。<code>offset</code>は、レコードを返す前にスキップするレコード数を指定します。例：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.limit(5)

</pre>
</div>
<p>上を実行するとクライアントが最大で5つ返されます。オフセットは指定されていないので、最初の5つがテーブルから取り出されます。この時実行されるSQLは以下のような感じになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 5

</pre>
</div>
<p><code>offset</code>を追加すると以下のようになります。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.limit(5).offset(30)

</pre>
</div>
<p>上のコードは、最初の30クライアントをスキップして31人目から最大5人のクライアントを返します。このときのSQLは以下のようになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 5 OFFSET 30

</pre>
</div>
<h3 id="グループ"><a href="#%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97">6 グループ</a></h3><p>検索メソッドで実行されるSQLに<code>GROUP BY</code>句を追加したい場合は、<code>group</code>メソッドを検索メソッドに追加できます。</p><p>たとえば、注文 (order) の作成日のコレクションを検索したい場合は、以下のようにします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")

</pre>
</div>
<p>上のコードは、データベースで注文のある日付ごとに<code>Order</code>オブジェクトを1つ作成します。</p><p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)

</pre>
</div>
<h4 id="グループ化された項目の合計"><a href="#%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97%E5%8C%96%E3%81%95%E3%82%8C%E3%81%9F%E9%A0%85%E7%9B%AE%E3%81%AE%E5%90%88%E8%A8%88">6.1 グループ化された項目の合計</a></h4><p>グループ化した項目の合計をひとつのクエリで得るには、<code>group</code>の次に<code>count</code>を呼び出します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Order.group(:status).count
# =&gt; { 'awaiting_approval' =&gt; 7, 'paid' =&gt; 12 }

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT COUNT (*) AS count_all, status AS status
FROM "orders"
GROUP BY status

</pre>
</div>
<h3 id="having"><a href="#having">7 Having</a></h3><p>SQLでは、<code>GROUP BY</code>フィールドで条件を指定する場合に<code>HAVING</code>句を使用します。検索メソッドで<code>:having</code>メソッドを使用すると、<code>Model.find</code>で生成されるSQLに<code>HAVING</code>句を追加できます。</p><p>以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Order.select("date(created_at) as ordered_date, sum(price) as total_price").
  group("date(created_at)").having("sum(price) &gt; ?", 100)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) &gt; 100

</pre>
</div>
<p>上の例では、1日あたり1つの注文 (order) オブジェクトを返しますが、1日あたりの注文合計が$100を超える場合にのみこれを行います。</p><h3 id="条件を上書きする"><a href="#%E6%9D%A1%E4%BB%B6%E3%82%92%E4%B8%8A%E6%9B%B8%E3%81%8D%E3%81%99%E3%82%8B">8 条件を上書きする</a></h3><h4 id="unscope"><a href="#unscope">8.1 <code>unscope</code></a></h4><p><code>unscope</code>を使用して特定の条件を取り除くことができます。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.where('id &gt; 10').limit(20).order('id asc').unscope(:order)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM articles WHERE id &gt; 10 LIMIT 20

# `unscope`する前のオリジナルのクエリ
SELECT * FROM articles WHERE id &gt; 10 ORDER BY id asc LIMIT 20


</pre>
</div>
<p>特定の<code>where</code>句で<code>unscope</code>を指定することもできます。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "articles".* FROM "articles" WHERE trashed = 0

</pre>
</div>
<p><code>unscope</code>をリレーションに適用すると、それにマージされるすべてのリレーションにも影響します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.order('id asc').merge(Article.unscope(:order))
# SELECT "articles".* FROM "articles"

</pre>
</div>
<h4 id="only"><a href="#only">8.2 <code>only</code></a></h4><p><code>only</code>メソッドを使用すると、条件を上書きできます。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.where('id &gt; 10').limit(20).order('id desc').only(:order, :where)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM articles WHERE id &gt; 10 ORDER BY id DESC

# `only`を使用する前のオリジナルのクエリ
SELECT "articles".* FROM "articles" WHERE (id &gt; 10) ORDER BY id desc LIMIT 20


</pre>
</div>
<h4 id="reorder"><a href="#reorder">8.3 <code>reorder</code></a></h4><p><code>reorder</code>メソッドは、デフォルトのスコープの並び順を上書きします。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ActiveRecord::Base
  has_many :comments, -&gt; { order('posted_at DESC') }
end

Article.find(10).comments.reorder('name')

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM articles WHERE id = 10
SELECT * FROM comments WHERE article_id = 10 ORDER BY name

</pre>
</div>
<p><code>reorder</code>を実行しなかった場合に実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM articles WHERE id = 10
SELECT * FROM comments WHERE article_id = 10 ORDER BY posted_at DESC

</pre>
</div>
<h4 id="reverse-order"><a href="#reverse-order">8.4 <code>reverse_order</code></a></h4><p><code>reverse_order</code>メソッドは、並び順が指定されている場合に並び順を逆にします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count &gt; 10").order(:name).reverse_order

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY name DESC

</pre>
</div>
<p>SQLクエリで並び順を指定する句がない場合に<code>reverse_order</code>を実行すると、主キーの逆順になります。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count &gt; 10").reverse_order

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY clients.id DESC

</pre>
</div>
<p>このメソッドは引数を<strong>取りません</strong>。</p><h4 id="rewhere"><a href="#rewhere">8.5 <code>rewhere</code></a></h4><p><code>rewhere</code>メソッドは、既存のwhere条件を上書きします。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.where(trashed: true).rewhere(trashed: false)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM articles WHERE `trashed` = 0

</pre>
</div>
<p><code>rewhere</code>の代わりに<code>where</code>を2回使用すると、結果が異なります。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.where(trashed: true).where(trashed: false)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM articles WHERE `trashed` = 1 AND `trashed` = 0

</pre>
</div>
<h3 id="nullリレーション"><a href="#null%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">9 Nullリレーション</a></h3><p><code>none</code>メソッドは、連鎖 (chain) 可能なリレーションを返します (レコードは返しません)。このメソッドから返されたリレーションにどのような条件を連鎖させても、常に空のリレーションが生成されます。これは、メソッドまたはスコープへの連鎖可能な応答が必要で、しかも結果を一切返したくない場合に便利です。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.none # 空のリレーションを返し、クエリを生成しない。

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# visible_articles メソッドはリレーションを1つ返すことが期待されている
@articles = current_user.visible_articles.where(name: params[:name])

def visible_articles
  case role
  when 'Country Manager'
    Article.where(country: country)
  when 'Reviewer'
    Article.published
  when 'Bad User'
    Article.none # =&gt; この場合[]またはnilを返し、呼び出し側のコードを中断する
  end
end

</pre>
</div>
<h3 id="読み取り専用オブジェクト"><a href="#%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8A%E5%B0%82%E7%94%A8%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88">10 読み取り専用オブジェクト</a></h3><p>Active Recordには、返されたどのオブジェクトに対しても変更を明示的に禁止する<code>readonly</code>メソッドがあります。読み取り専用を指定されたオブジェクトに対する変更の試みはすべて失敗し、<code>ActiveRecord::ReadOnlyRecord</code>例外が発生します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.readonly.first
client.visits += 1
client.save

</pre>
</div>
<p>上のコードでは <code>client</code>に対して明示的に<code>readonly</code>が指定されているため、 <em>visits</em> の値を更新して <code>client.save</code>を行なうと<code>ActiveRecord::ReadOnlyRecord</code>例外が発生します。</p><h3 id="レコードを更新できないようロックする"><a href="#%E3%83%AC%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B4%E6%96%B0%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E3%82%88%E3%81%86%E3%83%AD%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B">11 レコードを更新できないようロックする</a></h3><p>ロックは、データベースのレコードを更新する際の競合状態を避け、アトミックな (=中途半端な状態のない) 更新を行なうために有用です。</p><p>Active Recordには2とおりのロック機構があります。</p>
<ul>
<li>楽観的ロック (optimistic)</li>
<li>悲観的ロック (pessimistic)</li>
</ul>
<h4 id="楽観的ロック-optimistic"><a href="#%E6%A5%BD%E8%A6%B3%E7%9A%84%E3%83%AD%E3%83%83%E3%82%AF-optimistic">11.1 楽観的ロック (optimistic)</a></h4><p>楽観的ロックでは、複数のユーザーが同じレコードを編集することを許し、データの衝突が最小限であることを仮定しています。この方法では、レコードがオープンされてから変更されたことがあるかどうかをチェックします。そのような変更が行われ、かつ更新が無視された場合、<code>ActiveRecord::StaleObjectError</code>例外が発生します。</p><p><strong>楽観的ロックカラム</strong></p><p>楽観的ロックを使用するには、テーブルに<code>lock_version</code>という名前のinteger型カラムがある必要があります。Active Recordは、レコードが更新されるたびに<code>lock_version</code>カラムの値を1ずつ増やします。更新リクエストが発生したときの<code>lock_version</code>の値がデータベース上の<code>lock_version</code>カラムの値よりも小さい場合、更新リクエストは失敗し、<code>ActiveRecord::StaleObjectError</code>エラーが発生します。例：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
c1 = Client.find(1)
c2 = Client.find(1)

c1.first_name = "Michael"
c1.save

c2.name = "should fail"
c2.save # ActiveRecord::StaleObjectErrorを発生

</pre>
</div>
<p>例外の発生後、この例外をレスキューすることで衝突を解決する必要があります。衝突の解決方法は、ロールバック、マージ、またはビジネスロジックに応じた解決方法のいずれかを使用してください。</p><p><code>ActiveRecord::Base.lock_optimistically = false</code>を設定するとこの動作をオフにできます。</p><p><code>ActiveRecord::Base</code>には、<code>lock_version</code>カラム名を上書きするための<code>locking_column</code>が用意されています。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  self.locking_column = :lock_client_column
end

</pre>
</div>
<h4 id="悲観的ロック-pessimistic"><a href="#%E6%82%B2%E8%A6%B3%E7%9A%84%E3%83%AD%E3%83%83%E3%82%AF-pessimistic">11.2 悲観的ロック (pessimistic)</a></h4><p>悲観的ロックでは、データベースが提供するロック機構を使用します。リレーションの構築時に<code>lock</code>を使用すると、選択した行に対する排他的ロックを取得できます。<code>lock</code>を使用するリレーションは、デッドロック条件を回避するために通常トランザクションの内側にラップされます。</p><p>以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save!
end

</pre>
</div>
<p>バックエンドでMySQLを使用している場合、上のセッションによって以下のSQLが生成されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT

</pre>
</div>
<p>異なる種類のロックを使用したい場合、<code>lock</code>メソッドに生のSQLを渡すこともできます。たとえば、MySQLには<code>LOCK IN SHARE MODE</code>という式があります。これはレコードのロック中にも他のクエリからの読み出しは許可するものです。この式を指定するには、単にlockオプションの引数にします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
end

</pre>
</div>
<p>モデルのインスタンスが既にある場合は、トランザクションを開始してその中でロックを一度に取得できます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
item = Item.first
item.with_lock do
  # このブロックはトランザクション内で呼び出される
  # itemはロック済み
  item.increment!(:views)
end

</pre>
</div>
<h3 id="テーブルを結合する"><a href="#%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%82%92%E7%B5%90%E5%90%88%E3%81%99%E3%82%8B">12 テーブルを結合する</a></h3><p>Active Recordの検索メソッドには<code>joins</code>があり、生成されたSQLで<code>JOIN</code>句を使用できます。<code>joins</code>メソッドにはさまざまな使用方法があります。</p><h4 id="sqlフラグメント文字列を使用する"><a href="#sql%E3%83%95%E3%83%A9%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E6%96%87%E5%AD%97%E5%88%97%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B">12.1 SQLフラグメント文字列を使用する</a></h4><p><code>joins</code>メソッドの引数に生のSQLを指定することで<code>JOIN</code>句を指定できます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.joins('LEFT OUTER JOIN addresses ON addresses.client_id = clients.id')

</pre>
</div>
<p>これによって以下のSQLが生成されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT clients.* FROM clients LEFT OUTER JOIN addresses ON addresses.client_id = clients.id

</pre>
</div>
<h4 id="名前付き関連付けの配列-ハッシュを使用する"><a href="#%E5%90%8D%E5%89%8D%E4%BB%98%E3%81%8D%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E9%85%8D%E5%88%97-%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B">12.2 名前付き関連付けの配列/ハッシュを使用する</a></h4><div class="warning"><p>このメソッドは<code>INNER JOIN</code>でしか使用できません。</p></div><p>Active Recordでは、<code>joins</code>メソッドを使用して関連付けで<code>JOIN</code>句を指定する際に、モデルで定義された関連付けの名前をショートカットとして使用できます (詳細は<a href="association_basics.html">Active Recordの関連付け</a>を参照)。</p><p>たとえば、以下の<code>Category</code>、<code>Article</code>、<code>Comment</code>、<code>Guest</code>、<code>Tag</code>モデルについて考えてみましょう。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Category &lt; ActiveRecord::Base
  has_many :articles
end

class Article &lt; ActiveRecord::Base
  belongs_to :category
  has_many :comments
  has_many :tags
end

class Comment &lt; ActiveRecord::Base
  belongs_to :article
  has_one :guest
end

class Guest &lt; ActiveRecord::Base
  belongs_to :comment
end

class Tag &lt; ActiveRecord::Base
  belongs_to :article
end

</pre>
</div>
<p>以下のすべてにおいて、<code>INNER JOIN</code>を使用した結合クエリが期待どおりに生成されています。</p><h5 id="単一関連付けを結合する"><a href="#%E5%8D%98%E4%B8%80%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%92%E7%B5%90%E5%90%88%E3%81%99%E3%82%8B">12.2.1 単一関連付けを結合する</a></h5><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Category.joins(:articles)

</pre>
</div>
<p>上によって以下が生成されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT categories.* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id

</pre>
</div>
<p>上のSQLを日本語で書くと「記事 (article) のあるすべてのカテゴリーを含む、Categoryオブジェクトを1つ返す」となります。なお、同じカテゴリーに複数の記事がある場合、カテゴリーが重複します。重複のない一意のカテゴリーが必要な場合は、<code>Category.joins(:article).uniq</code>を使用できます。</p><h5 id="複数の関連付けを結合する"><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%92%E7%B5%90%E5%90%88%E3%81%99%E3%82%8B">12.2.2 複数の関連付けを結合する</a></h5><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.joins(:category, :comments)

</pre>
</div>
<p>上によって以下が生成されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT articles.* FROM articles
  INNER JOIN categories ON articles.category_id = categories.id
  INNER JOIN comments ON comments.article_id = articles.id

</pre>
</div>
<p>上のSQLを日本語で書くと、「カテゴリーが1つあり、かつコメントが1つ以上ある、すべての記事を返す」となります。こちらも、コメントが複数ある記事は複数回表示されます。</p><h5 id="ネストした関連付けを結合する-単一レベル"><a href="#%E3%83%8D%E3%82%B9%E3%83%88%E3%81%97%E3%81%9F%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%92%E7%B5%90%E5%90%88%E3%81%99%E3%82%8B-%E5%8D%98%E4%B8%80%E3%83%AC%E3%83%99%E3%83%AB">12.2.3 ネストした関連付けを結合する (単一レベル)</a></h5><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.joins(comments: :guest)

</pre>
</div>
<p>上によって以下が生成されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT articles.* FROM articles
  INNER JOIN comments ON comments.article_id = articles.id
  INNER JOIN guests ON guests.comment_id = comments.id

</pre>
</div>
<p>上のSQLを日本語で書くと、「ゲストによるコメントが1つある記事をすべて返す」となります。</p><h5 id="ネストした関連付けを結合する-複数レベル"><a href="#%E3%83%8D%E3%82%B9%E3%83%88%E3%81%97%E3%81%9F%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%92%E7%B5%90%E5%90%88%E3%81%99%E3%82%8B-%E8%A4%87%E6%95%B0%E3%83%AC%E3%83%99%E3%83%AB">12.2.4 ネストした関連付けを結合する (複数レベル)</a></h5><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Category.joins(articles: [{ comments: :guest }, :tags])

</pre>
</div>
<p>上によって以下が生成されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT categories.* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id
  INNER JOIN comments ON comments.article_id = articles.id
  INNER JOIN guests ON guests.comment_id = comments.id
  INNER JOIN tags ON tags.article_id = articles.id

</pre>
</div>
<h4 id="結合されたテーブルで条件を指定する"><a href="#%E7%B5%90%E5%90%88%E3%81%95%E3%82%8C%E3%81%9F%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%81%A7%E6%9D%A1%E4%BB%B6%E3%82%92%E6%8C%87%E5%AE%9A%E3%81%99%E3%82%8B">12.3 結合されたテーブルで条件を指定する</a></h4><p>標準の<a href="#%E9%85%8D%E5%88%97%E3%81%A7%E8%A1%A8%E3%81%95%E3%82%8C%E3%81%9F%E6%9D%A1%E4%BB%B6">配列</a>および<a href="#%E6%96%87%E5%AD%97%E5%88%97%E3%81%A0%E3%81%91%E3%81%A7%E8%A1%A8%E3%81%95%E3%82%8C%E3%81%9F%E6%9D%A1%E4%BB%B6">文字列</a>条件を使用して、結合テーブルに条件を指定することができます。<a href="#%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%9F%E6%9D%A1%E4%BB%B6">ハッシュ条件</a>の場合、結合テーブルで条件を指定する場合に特殊な構文を使用します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where('orders.created_at' =&gt; time_range)

</pre>
</div>
<p>さらに読みやすい別の方法として、ハッシュ条件をネストさせる方法があります。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where(orders: { created_at: time_range })

</pre>
</div>
<p>このコードでは、昨日作成された注文 (order) を持つすべてのクライアントを検索します。ここでもSQLの<code>BETWEEN</code>式を使用しています。</p><h3 id="関連付けを一括読み込みする"><a href="#%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%92%E4%B8%80%E6%8B%AC%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF%E3%81%99%E3%82%8B">13 関連付けを一括読み込みする</a></h3><p>一括読み込み (eager loading) とは、<code>Model.find</code>によって返されるオブジェクトに関連付けられたレコードを読み込むためのメカニズムであり、できるだけクエリの使用回数を減らすようにします。</p><p><strong>N + 1クエリ問題</strong></p><p>以下のコードについて考えてみましょう。クライアントを10人検索して郵便番号を表示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end

</pre>
</div>
<p>このコードは一見何の問題もないように見えます。しかし本当の問題は、実行されたクエリの回数が無駄に多いことなのです。上のコードでは、最初にクライアントを10人検索するのにクエリを1回発行し、次にそこから住所を取り出すのにクエリを10回発行しますので、合計で <strong>11</strong> 回のクエリが発行されます。</p><p><strong>N + 1クエリ問題を解決する</strong></p><p>Active Recordは、読み込まれるすべての関連付けを事前に指定することができます。これは、<code>Model.find</code>呼び出しで<code>includes</code>を指定することで実現できます。<code>includes</code>を指定すると、Active Recordは指定されたすべての関連付けが最小限のクエリ回数で読み込まれるようにしてくれます。</p><p>上の例で言うと、<code>Client.limit(10)</code>というコードを書き直して、住所が一括で読み込まれるようにします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
clients = Client.includes(:address).limit(10)

clients.each do |client|
  puts client.address.postcode
end

</pre>
</div>
<p>最初の例では <strong>11</strong> 回もクエリが実行されましたが、今度の例ではわずか <strong>2</strong> 回にまで減りました。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))

</pre>
</div>
<h4 id="複数の関連付けを一括で読み込む"><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%92%E4%B8%80%E6%8B%AC%E3%81%A7%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%80">13.1 複数の関連付けを一括で読み込む</a></h4><p>Active Recordは、1つの<code>Model.find</code>呼び出しで関連付けをいくつでも一括読み込みすることができます。これを行なうには、<code>includes</code>メソッドで配列、ハッシュ、または、配列やハッシュのネストしたハッシュを使用します。</p><h5 id="複数の関連付けの配列"><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E9%85%8D%E5%88%97">13.1.1 複数の関連付けの配列</a></h5><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.includes(:category, :comments)

</pre>
</div>
<p>上のコードは、記事と、それに関連付けられたカテゴリやコメントをすべて読み込みます。</p><h5 id="ネストした関連付けハッシュ"><a href="#%E3%83%8D%E3%82%B9%E3%83%88%E3%81%97%E3%81%9F%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5">13.1.2 ネストした関連付けハッシュ</a></h5><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Category.includes(articles: [{ comments: :guest }, :tags]).find(1)

</pre>
</div>
<p>上のコードは、id=1のカテゴリを検索し、関連付けられたすべての記事とそのタグやコメント、およびすべてのコメントのゲスト関連付けを一括読み込みします。</p><h4 id="関連付けの一括読み込みで条件を指定する"><a href="#%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E4%B8%80%E6%8B%AC%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF%E3%81%A7%E6%9D%A1%E4%BB%B6%E3%82%92%E6%8C%87%E5%AE%9A%E3%81%99%E3%82%8B">13.2 関連付けの一括読み込みで条件を指定する</a></h4><p>Active Recordでは、<code>joins</code>のように事前読み込みされた関連付けに対して条件を指定することができますが、<a href="#%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%82%92%E7%B5%90%E5%90%88%E3%81%99%E3%82%8B">joins</a> という方法を使用することをお勧めします。</p><p>しかし、このようにせざるを得ない場合は、<code>where</code>を通常どおりに使用することができます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.includes(:comments).where(comments: { visible: true })

</pre>
</div>
<p>このコードは、<code>LEFT OUTER JOIN</code>を含むクエリを1つ生成します。<code>joins</code>メソッドを使用していたら、代りに<code>INNER JOIN</code>を使用するクエリが生成されていたでしょう。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
  SELECT "articles"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "articles" LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE (comments.visible = 1)

</pre>
</div>
<p><code>where</code>条件がない場合は、通常のクエリが2セット生成されます。</p><div class="note"><p><code>where</code>がこのように動作するのは、ハッシュを渡した場合だけです。SQL断片化 (fragmentation) を避けるためには、<code>references</code> を指定して強制的にテーブルをjoinする必要があります。</p></div><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.includes(:comments).where("comments.visible = true").references(:comments)

</pre>
</div>
<p>この<code>includes</code>クエリの場合、どの記事にもコメントがついていないので、すべての記事が読み込まれます。<code>joins</code> (INNER JOIN) を使用する場合、結合条件は必ずマッチ <strong>しなければならず</strong> 、それ以外の場合にはレコードは返されません。</p><h3 id="スコープ"><a href="#%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97">14 スコープ</a></h3><p>スコープを設定することで、関連オブジェクトやモデルへのメソッド呼び出しとして参照される、よく使用されるクエリを指定することができます。スコープでは、<code>where</code>、<code>joins</code>、<code>includes</code>など、これまでに登場したすべてのメソッドを使用できます。どのスコープメソッドも、常に<code>ActiveRecord::Relation</code>オブジェクトを返します。このオブジェクトに対して、別のスコープを含む他のメソッド呼び出しを行なうこともできます。</p><p>単純なスコープを設定するには、クラスの内部で<code>scope</code>メソッドを使用し、スコープが呼び出されたときに実行して欲しいクエリをそこで渡します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ActiveRecord::Base
  scope :published, -&gt; { where(published: true) }
end

</pre>
</div>
<p>以下でもわかるように、スコープでのメソッドの設定は、クラスメソッドの定義と完全に同じ (というよりクラスメソッドの定義そのもの) です。どちらの形式を使用するかは好みの問題です。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ActiveRecord::Base
  def self.published
    where(published: true)
  end
end

</pre>
</div>
<p>スコープをスコープ内で連鎖 (chain) させることもできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ActiveRecord::Base
  scope :published,               -&gt; { where(published: true) }
  scope :published_and_commented, -&gt; { published.where("comments_count &gt; 0") }
end

</pre>
</div>
<p>この<code>published</code>スコープを呼び出すには、クラスでこのスコープを呼び出します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.published # =&gt; [published articles]

</pre>
</div>
<p>または、<code>Articles</code>オブジェクトからなる関連付けでこのスコープを呼び出します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
category = Category.first
category.articles.published # =&gt; [このカテゴリに属する、公開済みの記事]

</pre>
</div>
<h4 id="引数を渡す"><a href="#%E5%BC%95%E6%95%B0%E3%82%92%E6%B8%A1%E3%81%99">14.1 引数を渡す</a></h4><p>スコープには引数を渡すことができます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ActiveRecord::Base
  scope :created_before, -&gt;(time) { where("created_at &lt; ?", time) }
end

</pre>
</div>
<p>引数付きスコープの呼び出しは、クラスメソッドの呼び出しと同様の方法で行います。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Article.created_before(Time.zone.now)

</pre>
</div>
<p>しかし、スコープに引数を渡す機能は、クラスメソッドによって提供される機能を単に複製したものです。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ActiveRecord::Base
  def self.created_before(time)
    where("created_at &lt; ?", time)
  end
end

</pre>
</div>
<p>したがって、スコープで引数を使用するのであれば、クラスメソッドとして定義する方が推奨されます。クラスメソッドにした場合でも、関連オブジェクトからアクセス可能です。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
category.articles.created_before(time)

</pre>
</div>
<h4 id="デフォルトスコープを適用する"><a href="#%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%82%92%E9%81%A9%E7%94%A8%E3%81%99%E3%82%8B">14.2 デフォルトスコープを適用する</a></h4><p>あるスコープをモデルのすべてのクエリに適用したい場合、モデル自身の内部で<code>default_scope</code>メソッドを使用することができます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  default_scope { where("removed_at IS NULL") }
end

</pre>
</div>
<p>このモデルに対してクエリが実行されたときのSQLクエリは以下のような感じになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE removed_at IS NULL

</pre>
</div>
<p>デフォルトスコープの条件が複雑になるのであれば、スコープをクラスメソッドとして定義するのもひとつの手です。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  def self.default_scope
    # ActiveRecord::Relationを返すようにする
  end
end

</pre>
</div>
<h4 id="スコープのマージ"><a href="#%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%AE%E3%83%9E%E3%83%BC%E3%82%B8">14.3 スコープのマージ</a></h4><p><code>where</code>句と同様、スコープも<code>AND</code>条件でマージできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class User &lt; ActiveRecord::Base
  scope :active, -&gt; { where state: 'active' }
  scope :inactive, -&gt; { where state: 'inactive' }
end

User.active.inactive
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'

</pre>
</div>
<p><code>scope</code>と<code>where</code>条件を混用してマッチさせることができます。その結果生成される最終的なSQLには、すべての条件が<code>AND</code>で結合されます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.active.where(state: 'finished')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'

</pre>
</div>
<p>末尾のwhere句をどうしてもスコープより優先したい場合は、<code>Relation#merge</code>を使用できます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.active.merge(User.inactive)
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'

</pre>
</div>
<p>ここでひとつ注意しなければならないのは、<code>default_scope</code>で定義した条件が、<code>scope</code>や<code>where</code>で定義した条件よりも先に評価されるという点です。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class User &lt; ActiveRecord::Base
  default_scope { where state: 'pending' }
  scope :active, -&gt; { where state: 'active' }
  scope :inactive, -&gt; { where state: 'inactive' }
end

User.all
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'

User.active
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'active'

User.where(state: 'inactive')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'inactive'

</pre>
</div>
<p>上の例でわかるように、<code>default_scope</code>の条件が、<code>scope</code>と<code>where</code>の条件よりも先に評価されています。</p><h4 id="すべてのスコープを削除する"><a href="#%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%82%92%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B">14.4 すべてのスコープを削除する</a></h4><p>何らかの理由でスコープをすべて解除したい場合は<code>unscoped</code>メソッドを使用できます。このメソッドは、モデルで<code>default_scope</code>が指定されているが、それを適用したくないクエリがある場合に特に便利です。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.unscoped.load

</pre>
</div>
<p>このメソッドはスコープをすべて解除し、テーブルに対して通常の (スコープなしの) クエリを実行するようにします。</p><p><code>unscoped</code>に<code>scope</code>を連鎖させることはできませんので注意が必要です。このような場合は、<code>unscoped</code>のブロック形式を使用することが推奨されます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.unscoped {
  Client.created_before(Time.zone.now)
}

</pre>
</div>
<h3 id="動的ファインダ"><a href="#%E5%8B%95%E7%9A%84%E3%83%95%E3%82%A1%E3%82%A4%E3%83%B3%E3%83%80">15 動的ファインダ</a></h3><p>Active Recordは、テーブルに定義されたすべてのフィールド (属性とも呼ばれます) に対して自動的にファインダメソッドを提供します。たとえば、<code>Client</code>モデルに<code>first_name</code>というフィールドがあると、<code>find_by_first_name</code>というメソッドがActive Recordによって自動的に作成されます。<code>Client</code>モデルに<code>locked</code>というフィールドがあれば、<code>find_by_locked</code>というメソッドを使用できます。</p><p>この動的ファインダメソッドの末尾に<code>Client.find_by_name!("Ryan")</code>のように感嘆符 (<code>!</code>) を追加すると、該当するレコードがない場合に<code>ActiveRecord::RecordNotFound</code>エラーが発生します。</p><p>nameとlockedの両方を検索したいのであれば、2つのフィールド名をandでつなぐだけでメソッドを利用できます。たとえば、<code>Client.find_by_first_name_and_locked("Ryan", true)</code>のようにかくことができます</p><h3 id="メソッドチェインを理解する"><a href="#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%83%81%E3%82%A7%E3%82%A4%E3%83%B3%E3%82%92%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B">16 メソッドチェインを理解する</a></h3><p>Active Record パターンには <a href="http://en.wikipedia.org/wiki/Method_chaining">メソッドチェイン (Method chaining - Wikipedia)</a> が実装されています。これにより、複数のActive Recordメソッドをシンプルな方法で次々に適用することができます。</p><p>文中でメソッドチェインができるのは、その前のメソッドが<code>ActiveRecord::Relation</code> (<code>all</code>、<code>where</code>、<code>joins</code>など) をひとつ返す場合です。文の末尾には、単一のオブジェクトを返すメソッド (<a href="#%E5%8D%98%E4%B8%80%E3%81%AE%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99">単一のオブジェクトを取り出す</a>を参照) をひとつ置かなければなりません。</p><p>いくつか例をご紹介します。本ガイドでは一部の例のみをご紹介し、すべての例を網羅することはしません。
Active Recordメソッドが呼び出されると、クエリはその時点ではすぐに生成されず、データベースに送信されます。クエリは、データが実際に必要になった時点で初めて生成されます。以下の例では、いずれも単一のクエリを生成します。</p><h4 id="複数のテーブルからのデータをフィルタして取得する"><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%81%8B%E3%82%89%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF%E3%81%97%E3%81%A6%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B">16.1 複数のテーブルからのデータをフィルタして取得する</a></h4><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Person
  .select('people.id, people.name, comments.text')
  .joins(:comments)
  .where('comments.created_at &gt; ?', 1.week.ago)

</pre>
</div>
<p>結果は次のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT people.id, people.name, comments.text
FROM people
INNER JOIN comments
  ON comments.person_id = people.id
WHERE comments.created_at = '2015-01-01'

</pre>
</div>
<h4 id="複数のテーブルから特定のデータを取得する"><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%81%8B%E3%82%89%E7%89%B9%E5%AE%9A%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B">16.2 複数のテーブルから特定のデータを取得する</a></h4><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Person
  .select('people.id, people.name, companies.name')
  .joins(:company)
  .find_by('people.name' =&gt; 'John') # 名を指定

</pre>
</div>
<p>上のコードから以下が生成されます。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT people.id, people.name, companies.name
FROM people
INNER JOIN companies
  ON companies.person_id = people.id
WHERE people.name = 'John'
LIMIT 1

</pre>
</div>
<div class="note"><p>ひとつのクエリが複数のレコードとマッチする場合、<code>find_by</code>は「最初」の結果だけを返し、他は返しません (上の<code>LIMIT 1</code> 文を参照)。</p></div><h3 id="新しいオブジェクトを検索またはビルドする"><a href="#%E6%96%B0%E3%81%97%E3%81%84%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E6%A4%9C%E7%B4%A2%E3%81%BE%E3%81%9F%E3%81%AF%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B">17 新しいオブジェクトを検索またはビルドする</a></h3><p>レコードを検索し、レコードがなければ作成する、というのはよくある一連の流れです。<code>find_or_create_by</code>および<code>find_or_create_by!</code>メソッドを使用すればこれらを一度に行なうことができます。</p><h4 id="find-or-create-by"><a href="#find-or-create-by">17.1 <code>find_or_create_by</code></a></h4><p><code>find_or_create_by</code>メソッドは、指定された属性を持つレコードが存在するかどうかをチェックします。レコードがない場合は<code>create</code>が呼び出されます。以下の例を見てみましょう。</p><p>'Andy'という名前のクライアントを探し、いなければ作成したいとします。これを行なうには以下を実行します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_or_create_by(first_name: 'Andy')
# =&gt; #&lt;Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;

</pre>
</div>
<p>このメソッドによって生成されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT

</pre>
</div>
<p><code>find_or_create_by</code>は、既にあるレコードか新しいレコードのいずれかを返します。上の例の場合、Andyという名前のクライアントがなかったのでレコードを作成して返しました。</p><p><code>create</code>などと同様、検証にパスするかどうかによって、新しいレコードがデータベースに保存されていないことがあるかもしれません。</p><p>今度は、新しいレコードを作成するときに'locked'属性を<code>false</code>に設定したいが、それをクエリに含めたくないとします。そこで、"Andy"という名前のクライアントを検索するか、その名前のクライアントがいない場合は"Andy"というクライアントを作成してロックを外すことにします。</p><p>これは2とおりの方法で実装できます。1つ目は<code>create_with</code>を使用する方法です。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.create_with(locked: false).find_or_create_by(first_name: 'Andy')

</pre>
</div>
<p>2つ目はブロックを使用する方法です。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end

</pre>
</div>
<p>このブロックは、クライアントが作成されるときにだけ実行されます。このコードを再度実行すると、このブロックは実行されません。</p><h4 id="find-or-create-by-bang"><a href="#find-or-create-by-bang">17.2 <code>find_or_create_by!</code></a></h4><p><code>find_or_create_by!</code>を使用すると、新しいレコードが無効な場合に例外を発生することもできます。検証 (validation) については本ガイドでは解説していませんが、たとえば</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
validates :orders_count, presence: true

</pre>
</div>
<p>上を<code>Client</code>モデルに追加したとします。<code>orders_count</code>を指定しないで新しい<code>Client</code>モデルを作成しようとすると、レコードは無効になって例外が発生します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_or_create_by!(first_name: 'Andy')
# =&gt; ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank

</pre>
</div>
<h4 id="find-or-initialize-by"><a href="#find-or-initialize-by">17.3 <code>find_or_initialize_by</code></a></h4><p><code>find_or_initialize_by</code>メソッドは<code>find_or_create_by</code>と同様に動作しますが、<code>create</code>の代りに<code>new</code>を呼ぶ点が異なります。つまり、モデルの新しいインスタンスは作成されますが、その時点ではデータベースに保存されていません。<code>find_or_create_by</code>の例を少し変えて説明を続けます。今度は'Nick'という名前のクライアントが必要だとします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
nick = Client.find_or_initialize_by(first_name: 'Nick')
# =&gt; &lt;Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;

nick.persisted?
# =&gt; false

nick.new_record?
# =&gt; true

</pre>
</div>
<p>オブジェクトはまだデータベースに保存されていないため、生成されるSQLは以下のようなものになります。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.first_name = 'Nick') LIMIT 1

</pre>
</div>
<p>このオブジェクトをデータベースに保存したい場合は、単に<code>save</code>を呼び出します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
nick.save
# =&gt; true

</pre>
</div>
<h3 id="sqlで検索する"><a href="#sql%E3%81%A7%E6%A4%9C%E7%B4%A2%E3%81%99%E3%82%8B">18 SQLで検索する</a></h3><p>独自のSQLを使用してレコードを検索したい場合、<code>find_by_sql</code>メソッドを使用できます。この<code>find_by_sql</code>メソッドは、オブジェクトの配列を1つ返します。クエリがレコードを1つしか返さなかった場合にも配列が返されますのでご注意ください。たとえば、以下のクエリを実行したとします。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_by_sql("SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc")
&gt;
  #&lt;Client id: 1, first_name: "Lucas" &gt;,
  #&lt;Client id: 2, first_name: "Jan" &gt;,
  # ...
]

</pre>
</div>
<p><code>find_by_sql</code>は、カスタマイズしたデータベース呼び出しを簡単な方法で提供し、インスタンス化されたオブジェクトを返します。</p><h4 id="select-all"><a href="#select-all">18.1 <code>select_all</code></a></h4><p><code>find_by_sql</code>は<code>connection#select_all</code>と深い関係があります。<code>select_all</code>は<code>find_by_sql</code>と同様、カスタムSQLを使用してデータベースからオブジェクトを取り出しますが、取り出したオブジェクトのインスタンス化を行わない点が異なります。代りに、ハッシュの配列を返します。1つのハッシュが1レコードを表します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.connection.select_all("SELECT first_name, created_at FROM clients WHERE id = '1'")
# =&gt; [
  {"first_name"=&gt;"Rafael", "created_at"=&gt;"2012-11-10 23:23:45.281189"},
  {"first_name"=&gt;"Eileen", "created_at"=&gt;"2013-12-09 11:22:35.221282"}
]

</pre>
</div>
<h4 id="pluck"><a href="#pluck">18.2 <code>pluck</code></a></h4><p><code>pluck</code>は、1つのモデルで使用されているテーブルからカラム (1つでも複数でも可) を取得するクエリを送信するのに使用できます。引数としてカラム名のリストを与えると、指定したカラムの値の配列を、対応するデータ型で返します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(active: true).pluck(:id)
# SELECT id FROM clients WHERE active = 1
# =&gt; [1, 2, 3]

Client.distinct.pluck(:role)
# SELECT DISTINCT role FROM clients
# =&gt; ['admin', 'member', 'guest']

Client.pluck(:id, :name)
# SELECT clients.id, clients.name FROM clients
# =&gt; [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]

</pre>
</div>
<p><code>pluck</code>を使用すると、以下のようなコードをシンプルなものに置き換えることができます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.select(:id).map { |c| c.id }
# または
Client.select(:id).map(&amp;:id)
# または
Client.select(:id, :name).map { |c| [c.id, c.name] }

</pre>
</div>
<p>上は以下に置き換えられます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.pluck(:id)
# または
Client.pluck(:id, :name)

</pre>
</div>
<p><code>select</code>と異なり、<code>pluck</code>はデータベースから受け取った結果を直接Rubyの配列に変換してくれます。そのための<code>ActiveRecord</code>オブジェクトを事前に構成しておく必要はありません。従って、このメソッドは大規模なクエリや使用頻度の高いクエリで使用するとパフォーマンスが向上します。ただし、オーバーライドを行なうモデルメソッドは使用できません。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  def name
    "私は#{super}"
  end
end

Client.select(:name).map &amp;:name
# =&gt; ["私はDavid", "私はJeremy", "私はJose"]

Client.pluck(:name)
# =&gt; ["David", "Jeremy", "Jose"]

</pre>
</div>
<p>さらに<code>pluck</code>は、<code>select</code>などの<code>Relation</code>スコープと異なり、クエリを直接トリガするので、その後ろに他のスコープを連鎖することはできません。ただし、構成済みのスコープを<code>pluck</code>の前に置くことはできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.pluck(:name).limit(1)
# =&gt; NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;

Client.limit(1).pluck(:name)
# =&gt; ["David"]

</pre>
</div>
<h4 id="ids"><a href="#ids">18.3 <code>ids</code></a></h4><p><code>ids</code>は、テーブルの主キーを使用するリレーションのIDをすべて取り出すのに使用できます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Person.ids
# SELECT id FROM people

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  self.primary_key = "person_id"
end

Person.ids
# SELECT person_id FROM people

</pre>
</div>
<h3 id="オブジェクトの存在チェック"><a href="#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%AD%98%E5%9C%A8%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF">19 オブジェクトの存在チェック</a></h3><p>オブジェクトが存在するかどうかは、<code>exists?</code>このメソッドは、<code>find</code>と同様のクエリを使用してデータベースにクエリを送信しますが、オブジェクトのコレクションの代わりに<code>true</code>または<code>false</code>を返します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.exists?(1)

</pre>
</div>
<p><code>exists?</code>は複数の値を引数に取ることができます。ただし、それらの値のうち1つでも存在していれば、他の値が存在していなくても<code>true</code>を返します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.exists?(id: [1,2,3])
# または
Client.exists?(name: ['John', 'Sergei'])

</pre>
</div>
<p><code>exists?</code>メソッドは、引数なしでモデルやリレーションに使用することもできます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(first_name: 'Ryan').exists?

</pre>
</div>
<p>上の例では、<code>first_name</code>が'Ryan'のクライアントが1人でもいれば<code>true</code>を返し、それ以外の場合は<code>false</code>を返します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.exists?

</pre>
</div>
<p>上の例では、<code>Client</code>テーブルが空なら<code>false</code>を返し、それ以外の場合は<code>true</code>を返します。</p><p>モデルやリレーションでの存在チェックには<code>any?</code>や<code>many?</code>も使用できます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# via a model
Article.any?
Article.many?

# 名前付きスコープを経由
Article.recent.any?
Article.recent.many?

# リレーション経由
Article.where(published: true).any?
Article.where(published: true).many?

# 関連付け経由
Article.first.categories.any?
Article.first.categories.many?

</pre>
</div>
<h3 id="計算"><a href="#%E8%A8%88%E7%AE%97">20 計算</a></h3><p>このセクションでは冒頭で<code>count</code>メソッドを例に取って説明していますが、ここで説明されているオプションは以下のすべてのサブセクションにも該当します。</p><p>あらゆる計算メソッドは、モデルに対して直接実行されます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.count
# SELECT count(*) AS count_all FROM clients

</pre>
</div>
<p>リレーションに対しても直接実行されます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(first_name: 'Ryan').count
# SELECT count(*) AS count_all FROM clients WHERE (first_name = 'Ryan')

</pre>
</div>
<p>この他にも、リレーションに対してさまざまなファインダメソッドを使用して複雑な計算を行なうことができます。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.includes("orders").where(first_name: 'Ryan', orders: { status: 'received' }).count

</pre>
</div>
<p>上のコードは以下を実行します。</p><div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT count(DISTINCT clients.id) AS count_all FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = client.id WHERE
  (clients.first_name = 'Ryan' AND orders.status = 'received')

</pre>
</div>
<h4 id="個数を数える"><a href="#%E5%80%8B%E6%95%B0%E3%82%92%E6%95%B0%E3%81%88%E3%82%8B">20.1 個数を数える</a></h4><p>モデルのテーブルに含まれるレコードの個数を数えるには<code>Client.count</code>を使用できます。返されるのはレコードの個数です。特定の年齢のクライアントの数を数えるのであれば、<code>Client.count(:age)</code>とします</p><p>オプションについては、1つ上の<a href="#%E8%A8%88%E7%AE%97">計算</a>セクションを参照してください。</p><h4 id="平均"><a href="#%E5%B9%B3%E5%9D%87">20.2 平均</a></h4><p>テーブルに含まれる特定の数値の平均を得るには、そのテーブルを持つクラスに対して<code>average</code>メソッドを呼び出します。このメソッド呼び出しは以下のようなものになります。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.average("orders_count")

</pre>
</div>
<p>返される値は、そのフィールドの平均値です。通常3.14159265のような浮動小数点になります。</p><p>オプションについては、1つ上の<a href="#%E8%A8%88%E7%AE%97">計算</a>セクションを参照してください。</p><h4 id="最小値"><a href="#%E6%9C%80%E5%B0%8F%E5%80%A4">20.3 最小値</a></h4><p>テーブルに含まれるフィールドの最小値を得るには、そのテーブルを持つクラスに対して<code>minimum</code>メソッドを呼び出します。このメソッド呼び出しは以下のようなものになります。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.minimum("age")

</pre>
</div>
<p>オプションについては、1つ上の<a href="#%E8%A8%88%E7%AE%97">計算</a>セクションを参照してください。</p><h4 id="最大値"><a href="#%E6%9C%80%E5%A4%A7%E5%80%A4">20.4 最大値</a></h4><p>テーブルに含まれるフィールドの最大値を得るには、そのテーブルを持つクラスに対して<code>maximum</code>メソッドを呼び出します。このメソッド呼び出しは以下のようなものになります。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.maximum("age")

</pre>
</div>
<p>オプションについては、1つ上の<a href="#%E8%A8%88%E7%AE%97">計算</a>セクションを参照してください。</p><h4 id="合計"><a href="#%E5%90%88%E8%A8%88">20.5 合計</a></h4><p>テーブルに含まれるフィールドのすべてのレコードにおける合計を得るには、そのテーブルを持つクラスに対して<code>sum</code>メソッドを呼び出します。このメソッド呼び出しは以下のようなものになります。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.sum("orders_count")

</pre>
</div>
<p>オプションについては、1つ上の<a href="#%E8%A8%88%E7%AE%97">計算</a>セクションを参照してください。</p><h3 id="explainを実行する"><a href="#explain%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B">21 EXPLAINを実行する</a></h3><p>リレーションによってトリガされるクエリでEXPLAINを実行することができます。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.where(id: 1).joins(:articles).explain

</pre>
</div>
<p>以下のような結果が生成されます。</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+----------+-------+---------------+
| id | select_type | table    | type  | possible_keys |
+----+-------------+----------+-------+---------------+
|  1 | SIMPLE      | users    | const | PRIMARY       |
|  1 | SIMPLE      | articles | ALL   | NULL          |
+----+-------------+----------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)

</pre>
</div>
<p>上の結果はMySQLの場合です。</p><p>Active Recordは、データベースシェルを模したデータをある程度整形して出力します。PostgreSQLアダプタで同じクエリを実行すると、今度は以下のような結果が得られます。</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "articles" ON "articles"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (articles.user_id = users.id)
   -&gt;  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   -&gt;  Seq Scan on articles  (cost=0.00..28.88 rows=8 width=4)
         Filter: (articles.user_id = 1)
(6 rows)

</pre>
</div>
<p>一括読み込みを使用していると、内部で複数のクエリがトリガされることがあり、一部のクエリではその前の結果を必要とすることがあります。このため、<code>explain</code>はこのクエリを実際に実行し、それからクエリプランを要求します。以下に例を示します。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.where(id: 1).includes(:articles).explain

</pre>
</div>
<p>以下の結果を生成します。</p><div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+
| id | select_type | table | type  | possible_keys |
+----+-------------+-------+-------+---------------+
|  1 | SIMPLE      | users | const | PRIMARY       |
+----+-------------+-------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `articles`.* FROM `articles`  WHERE `articles`.`user_id` IN (1)
+----+-------------+----------+------+---------------+
| id | select_type | table    | type | possible_keys |
+----+-------------+----------+------+---------------+
|  1 | SIMPLE      | articles | ALL  | NULL          |
+----+-------------+----------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)

</pre>
</div>
<p>上の結果はMySQLの場合です。</p><h4 id="explainの出力結果を解釈する"><a href="#explain%E3%81%AE%E5%87%BA%E5%8A%9B%E7%B5%90%E6%9E%9C%E3%82%92%E8%A7%A3%E9%87%88%E3%81%99%E3%82%8B">21.1 EXPLAINの出力結果を解釈する</a></h4><p>EXPLAINの出力を解釈することは、本ガイドの範疇を超えます。以下の情報を参考にしてください。</p>
<ul>
<li><p>SQLite3: <a href="http://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p></li>
<li><p>MySQL: <a href="http://dev.mysql.com/doc/refman/5.6/en/explain-output.html">EXPLAIN Output Format</a> </p></li>
<li><p>PostgreSQL: <a href="http://www.postgresql.org/docs/current/static/using-explain.html">Using EXPLAIN</a></p></li>
</ul>

        

        <h3 id="feedback"><a href="#feedback">フィードバックについて</a></h3>
        <p>
          本ガイドは GitHub上の <a href="https://github.com/yasslab/railsguides.jp">yasslab/railsguides.jp</a> で管理・公開されております。
          本ガイドを読んで気になる文章や間違ったコードを見かけたら、上記リポジトリにてお気軽に <a href="https://github.com/yasslab/railsguides.jp/issues">Issue</a> を出して頂けると嬉しいです。また、「Pull Request を送りたい!」という場合には、<a href="ruby_on_rails_guides_guidelines.html">Ruby on Railsガイドのガイドライン</a>と、<a href="https://github.com/yasslab/railsguides.jp#%E7%BF%BB%E8%A8%B3%E3%81%AE%E6%B5%81%E3%82%8C">README</a>に記載されている「翻訳の流れ」をご参考にしてください。
        </p>
        <p>
          なお、原著における間違いを見つけたら、「Ruby on Railsに貢献する方法」に記されている<a href="/contributing_to_ruby_on_rails.html#rails%E3%81%AE%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%81%AB%E8%B2%A2%E7%8C%AE%E3%81%99%E3%82%8B">Railsのドキュメントに貢献する</a>を参考にしながら、ぜひRailsコミュニティに貢献してみてしてください :)
        </p>
        <p>
          本ガイドの品質向上に向けて、皆さまのご協力が得られれば幸いです。よろしくお願い致します。
        </p>
        <ol class="snsb" style="margin-left: 0px">
	  <li><div class="fb-like" data-href="http://railsguides.jp/" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true"></div></li>
	  <li><a href="https://twitter.com/share" class="twitter-share-button" data-url="http://railsguides.jp/" data-text="Ruby on Rails ガイド：体系的に Rails を学ぼう" data-lang="en" data-hashtags="Railsガイド" data-via="RailsGuidesJP" width="100">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          <li><iframe src="http://ghbtns.com/github-btn.html?user=yasslab&repo=railsguides.jp&type=watch&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="80" height="20"></iframe></li>
          <li><a href="http://b.hatena.ne.jp/entry/railsguides.jp" class="hatena-bookmark-button" data-hatena-bookmark-title="Ruby on Rails ガイド：体系的に Rails を学ぼう" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="http://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="http://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script></li>          
	  <li><div class="g-plusone" data-size="medium" data-lang="ja"></div>
	    <script type="text/javascript">
	      (function() {
                var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
                po.src = 'https://apis.google.com/js/plusone.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	      })();
	    </script>
	  </li>
        </ol>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <div class="sitemap">
          <dl class="L">
            <dt>はじめに</dt>
              <dd><a href="getting_started.html">Rails をはじめよう</a></dd>
            <dt>モデル</dt>
              <dd><a href="active_record_basics.html">Active Record の基礎</a></dd>
              <dd><a href="active_record_migrations.html">Active Record マイグレーション</a></dd>
              <dd><a href="active_record_validations.html">Active Record バリデーション</a></dd>
              <dd><a href="active_record_callbacks.html">Active Record コールバック</a></dd>
              <dd><a href="association_basics.html">Active Record の関連付け</a></dd>
              <dd><a href="active_record_querying.html">Active Record クエリインターフェイス</a></dd>
              <dd><a href="active_model_basics.html">Active Model の基礎</a></dd>
            <dt>ビュー</dt>
              <dd><a href="action_view_overview.html">Action View の概要</a></dd>
              <dd><a href="layouts_and_rendering.html">レイアウトとレンダリング</a></dd>
              <dd><a href="form_helpers.html">Action View フォームヘルパー</a></dd>
            <dt>コントローラ</dt>
              <dd><a href="action_controller_overview.html">Action Controller の概要</a></dd>
              <dd><a href="routing.html">Rails ルーティング</a></dd>
          </dl>
          <dl class="C">
            <dt>高度なトピック</dt>
              <dd><a href="active_support_core_extensions.html">Active Support コア拡張機能</a></dd>
              <dd><a href="i18n.html">Rails 国際化 (i18n) API</a></dd>
              <dd><a href="action_mailer_basics.html">Action Mailer の基礎</a></dd>
              <dd><a href="active_job_basics.html">Active Job の基礎</a></dd>
              <dd><a href="testing.html">Rails テスティングガイド</a></dd>
              <dd><a href="security.html">Rails セキュリティガイド</a></dd>
              <dd><a href="debugging_rails_applications.html">Rails アプリケーションのデバッグ</a></dd>
              <dd><a href="configuring.html">Rails アプリケーションを設定する</a></dd>
              <dd><a href="command_line.html">コマンドラインツールと Rake タスク</a></dd>
              <dd><a href="asset_pipeline.html">アセットパイプライン</a></dd>
              <dd><a href="working_with_javascript_in_rails.html">Rails で JavaScript を使用する</a></dd>
              <dd><a href="initialization.html">Rails の初期化プロセス</a></dd>
              <dd><a href="autoloading_and_reloading_constants.html">定数の自動読み込みと再読み込み</a></dd>
              <dd><a href="caching_with_rails.html">Rails のキャッシュ: 概要</a></dd>
              <dd><a href="active_support_instrumentation.html">Active Support の Instrumentation 機能</a></dd>
              <dd><a href="profiling.html">Rails アプリケーションのプロファイリング</a></dd>
              <dd><a href="api_app.html">Rails による API 専用アプリ</a></dd>
              <dd><a href="action_cable_overview.html">Action Cable の概要</a></dd>
            <dt>Rails を拡張する</dt>
              <dd><a href="plugins.html">Rails プラグイン作成入門</a></dd>
              <dd><a href="rails_on_rack.html">Rails と Rack</a></dd>
              <dd><a href="generators.html">Rails ジェネレータとテンプレート入門</a></dd>
              <dd><a href="engines.html">Rails エンジン入門</a></dd>
          </dl>
          <dl class="R">
            <dt>Ruby on Rails に貢献する</dt>
              <dd><a href="contributing_to_ruby_on_rails.html">Ruby on Rails に貢献する方法</a></dd>
              <dd><a href="development_dependencies_install.html">Rails コア開発環境の構築方法</a></dd>
              <dd><a href="api_documentation_guidelines.html">API ドキュメント作成ガイドライン</a></dd>
              <dd><a href="ruby_on_rails_guides_guidelines.html">Rails ガイドのガイドライン</a></dd>
            <dt>メンテナンスポリシー</dt>
              <dd><a href="maintenance_policy.html">メンテナンスポリシー</a></dd>
            <dt>リリースノート</dt>
              <dd><a href="upgrading_ruby_on_rails.html">Rails アップグレードガイド</a></dd>
              <dd><a href="5_0_release_notes.html">Ruby on Rails 5.0 リリースノート</a></dd>
              <dd><a href="4_2_release_notes.html">Ruby on Rails 4.2 リリースノート</a></dd>
              <dd><a href="4_1_release_notes.html">Ruby on Rails 4.1 リリースノート</a></dd>
              <dd><a href="4_0_release_notes.html">Ruby on Rails 4.0 リリースノート</a></dd>
              <dd><a href="3_2_release_notes.html">Ruby on Rails 3.2 Release Notes [未着手]</a></dd>
              <dd><a href="3_1_release_notes.html">Ruby on Rails 3.1 Release Notes [未着手]</a></dd>
              <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes [未着手]</a></dd>
              <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes [未着手]</a></dd>
              <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes [未着手]</a></dd>
          </dl>
      </div>

      <ol class="snsb" style="padding-top: 20px">
	<li>本ガイドは<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.ja">クリエイティブ・コモンズ 表示-継承 4.0 国際</a> (CC BY-SA 4.0) ライセンスに基づいて公開されています。また、「Rails」および「Ruby on Rails」という名称、そして Rails のロゴは、David Heinemeier Hansson による登録商標で、すべての権利を有しています。</li>
      </ol>
    </div>
  </div>
</h5>
  <script type="text/javascript" src="javascripts/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/responsive-tables.js"></script>
  <script type="text/javascript" src="javascripts/guides.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushRuby.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushXml.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushSql.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all();
    $(guidesIndex.bind);
  </script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-50163209-4', 'auto');
    ga('send', 'pageview');
  </script>
</body>
</html>
